<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>compiler &mdash; BeanMachine  documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="diagnostics" href="beanmachine.ppl.diagnostics.html" />
    <link rel="prev" title="beanmachine.ppl" href="beanmachine.ppl.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> BeanMachine
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="beanmachine.html">beanmachine</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">compiler</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-beanmachine.ppl.compiler.ast_patterns">beanmachine.ppl.compiler.ast_patterns module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-ast-tools-module">beanmachine.ppl.compiler.ast_tools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-beanmachine.ppl.compiler.beanstalk_common">beanmachine.ppl.compiler.beanstalk_common module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-bm-graph-builder-module">beanmachine.ppl.compiler.bm_graph_builder module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-bm-to-bmg-module">beanmachine.ppl.compiler.bm_to_bmg module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-bmg-node-types-module">beanmachine.ppl.compiler.bmg_node_types module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-bmg-nodes-module">beanmachine.ppl.compiler.bmg_nodes module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-bmg-requirements-module">beanmachine.ppl.compiler.bmg_requirements module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-beanmachine.ppl.compiler.bmg_types">beanmachine.ppl.compiler.bmg_types module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-error-report-module">beanmachine.ppl.compiler.error_report module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-fix-additions-module">beanmachine.ppl.compiler.fix_additions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-fix-bool-arithmetic-module">beanmachine.ppl.compiler.fix_bool_arithmetic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-fix-bool-comparisons-module">beanmachine.ppl.compiler.fix_bool_comparisons module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-fix-multiary-ops-module">beanmachine.ppl.compiler.fix_multiary_ops module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-fix-observations-module">beanmachine.ppl.compiler.fix_observations module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-fix-observe-true-module">beanmachine.ppl.compiler.fix_observe_true module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-fix-problem-module">beanmachine.ppl.compiler.fix_problem module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-fix-problems-module">beanmachine.ppl.compiler.fix_problems module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-fix-requirements-module">beanmachine.ppl.compiler.fix_requirements module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-fix-unsupported-module">beanmachine.ppl.compiler.fix_unsupported module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-gen-bmg-cpp-module">beanmachine.ppl.compiler.gen_bmg_cpp module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-gen-bmg-graph-module">beanmachine.ppl.compiler.gen_bmg_graph module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-gen-bmg-python-module">beanmachine.ppl.compiler.gen_bmg_python module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-gen-builder-module">beanmachine.ppl.compiler.gen_builder module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-gen-dot-module">beanmachine.ppl.compiler.gen_dot module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-graph-labels-module">beanmachine.ppl.compiler.graph_labels module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-beanmachine.ppl.compiler.hint">beanmachine.ppl.compiler.hint module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-internal-error-module">beanmachine.ppl.compiler.internal_error module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-lattice-typer-module">beanmachine.ppl.compiler.lattice_typer module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-beanmachine.ppl.compiler.patterns">beanmachine.ppl.compiler.patterns module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-beanmachine.ppl.compiler.performance_report">beanmachine.ppl.compiler.performance_report module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-beanmachine.ppl.compiler.profiler">beanmachine.ppl.compiler.profiler module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-beanmachine.ppl.compiler.rules">beanmachine.ppl.compiler.rules module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-runtime-module">beanmachine.ppl.compiler.runtime module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-beanmachine.ppl.compiler.single_assignment">beanmachine.ppl.compiler.single_assignment module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beanmachine-ppl-compiler-typer-base-module">beanmachine.ppl.compiler.typer_base module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-beanmachine.ppl.compiler">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="beanmachine.ppl.diagnostics.html">diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="beanmachine.ppl.distribution.html">distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="beanmachine.ppl.examples.conjugate_models.html">examples.conjugate_models</a></li>
<li class="toctree-l1"><a class="reference internal" href="experimental.html">experimental</a></li>
<li class="toctree-l1"><a class="reference internal" href="experimental.html#indices-and-tables">Indices and tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="beanmachine.ppl.inference.proposer.html">inference.proposer package</a></li>
<li class="toctree-l1"><a class="reference internal" href="beanmachine.ppl.inference.html">inference package</a></li>
<li class="toctree-l1"><a class="reference internal" href="beanmachine.ppl.model.html">model</a></li>
<li class="toctree-l1"><a class="reference internal" href="beanmachine.ppl.html">beanmachine.ppl</a></li>
<li class="toctree-l1"><a class="reference internal" href="beanmachine.ppl.testlib.html">testlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="beanmachine.ppl.utils.html">utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="beanmachine.ppl.world.html">world</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BeanMachine</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="beanmachine.html">beanmachine</a> &raquo;</li>
          <li><a href="beanmachine.ppl.html">beanmachine.ppl</a> &raquo;</li>
      <li>compiler</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/beanmachine.ppl.compiler.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="compiler">
<h1>compiler<a class="headerlink" href="#compiler" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-beanmachine.ppl.compiler.ast_patterns">
<span id="beanmachine-ppl-compiler-ast-patterns-module"></span><h2>beanmachine.ppl.compiler.ast_patterns module<a class="headerlink" href="#module-beanmachine.ppl.compiler.ast_patterns" title="Permalink to this headline">¶</a></h2>
<p>Pattern matching for ASTs</p>
<dl class="class">
<dt id="beanmachine.ppl.compiler.ast_patterns.ConstantList">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ConstantList</code><a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ConstantList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>A recursively-defined pattern which matches a list expression containing only
numeric literals, or lists of numeric literals, and so on.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.ast_patterns.ConstantList.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ConstantList.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.arguments">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">arguments</code><span class="sig-paren">(</span><em>args: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>vararg: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>kwonlyargs: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>kw_defaults: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>kwarg: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>defaults: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.arguments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.assign">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">assign</code><span class="sig-paren">(</span><em>targets: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>value: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.assign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_assert">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_assert</code><span class="sig-paren">(</span><em>expr: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>msg: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_assert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_boolop">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_boolop</code><span class="sig-paren">(</span><em>op: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>values: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_boolop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_compare">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_compare</code><span class="sig-paren">(</span><em>left: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>ops: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>comparators: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_compare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_dict">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_dict</code><span class="sig-paren">(</span><em>keys: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>values: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_dictComp">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_dictComp</code><span class="sig-paren">(</span><em>key: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>value: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>generators: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_dictComp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_for">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_for</code><span class="sig-paren">(</span><em>target: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>iter: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>body: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>orelse: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_for" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_if">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_if</code><span class="sig-paren">(</span><em>test: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>body: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>orelse: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_if" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_list">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_list</code><span class="sig-paren">(</span><em>elts: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>ctx: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>ast_op=&lt;class '_ast.List'&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_listComp">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_listComp</code><span class="sig-paren">(</span><em>elt: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>generators: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_listComp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_luple">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_luple</code><span class="sig-paren">(</span><em>elts: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>ctx: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_luple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_return">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_return</code><span class="sig-paren">(</span><em>value: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_return" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_setComp">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_setComp</code><span class="sig-paren">(</span><em>elt: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>generators: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_setComp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_str">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_str</code><span class="sig-paren">(</span><em>s: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_str" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_to_constant_value">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_to_constant_value</code><span class="sig-paren">(</span><em>x: _ast.AST</em><span class="sig-paren">)</span> &#x2192; Any<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_to_constant_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.ast_while">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">ast_while</code><span class="sig-paren">(</span><em>test: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>body: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>orelse: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.ast_while" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.attribute">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">attribute</code><span class="sig-paren">(</span><em>value: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>attr: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>ctx: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.attribute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.binary_compare">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">binary_compare</code><span class="sig-paren">(</span><em>op: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.binary_compare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.binop">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">binop</code><span class="sig-paren">(</span><em>op: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>left: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>right: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.binop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.boolop">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">boolop</code><span class="sig-paren">(</span><em>op: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>values: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.boolop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.call">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">call</code><span class="sig-paren">(</span><em>func: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>args: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>keywords: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.call" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.call_to">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">call_to</code><span class="sig-paren">(</span><em>id: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>args: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.call_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.compare">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">compare</code><span class="sig-paren">(</span><em>left: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>ops: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>comparators: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.compare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.constant_value_to_ast">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">constant_value_to_ast</code><span class="sig-paren">(</span><em>x: Any</em><span class="sig-paren">)</span> &#x2192; _ast.AST<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.constant_value_to_ast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.equal">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">equal</code><span class="sig-paren">(</span><em>left: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>right: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.equal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.expr">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">expr</code><span class="sig-paren">(</span><em>value: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.expr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.function_def">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">function_def</code><span class="sig-paren">(</span><em>name: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>args: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>body: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>decorator_list: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>returns: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.function_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.greater_than">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">greater_than</code><span class="sig-paren">(</span><em>left: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>right: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.greater_than" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.greater_than_equal">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">greater_than_equal</code><span class="sig-paren">(</span><em>left: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>right: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.greater_than_equal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.id_from_call">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">id_from_call</code><span class="sig-paren">(</span><em>c: _ast.Call</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.id_from_call" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.if_exp">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">if_exp</code><span class="sig-paren">(</span><em>test: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>body: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>orelse: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.if_exp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.if_statement">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">if_statement</code><span class="sig-paren">(</span><em>test: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>body: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>orelse: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.index">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">index</code><span class="sig-paren">(</span><em>value: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.keyword">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">keyword</code><span class="sig-paren">(</span><em>arg: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>value: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.keyword" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.less_than">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">less_than</code><span class="sig-paren">(</span><em>left: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>right: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.less_than" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.less_than_equal">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">less_than_equal</code><span class="sig-paren">(</span><em>left: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>right: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.less_than_equal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.module">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">module</code><span class="sig-paren">(</span><em>body: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.module" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.name">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">name</code><span class="sig-paren">(</span><em>id: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>ctx: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.name_constant">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">name_constant</code><span class="sig-paren">(</span><em>value: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.name_constant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.not_equal">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">not_equal</code><span class="sig-paren">(</span><em>left: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>right: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.not_equal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.num">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">num</code><span class="sig-paren">(</span><em>n: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.num" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.slice_pattern">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">slice_pattern</code><span class="sig-paren">(</span><em>lower: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>upper: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>step: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.slice_pattern" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.starred">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">starred</code><span class="sig-paren">(</span><em>value: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>ctx: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.starred" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.subscript">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">subscript</code><span class="sig-paren">(</span><em>value: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>slice: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>ctx: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.subscript" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.tensor_single_value">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">tensor_single_value</code><span class="sig-paren">(</span><em>p: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.tensor_single_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.unaryop">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">unaryop</code><span class="sig-paren">(</span><em>op: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>operand: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.unaryop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.ast_patterns.unarysub">
<code class="descclassname">beanmachine.ppl.compiler.ast_patterns.</code><code class="descname">unarysub</code><span class="sig-paren">(</span><em>operand: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.ast_patterns.unarysub" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="beanmachine-ppl-compiler-ast-tools-module">
<h2>beanmachine.ppl.compiler.ast_tools module<a class="headerlink" href="#beanmachine-ppl-compiler-ast-tools-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-beanmachine.ppl.compiler.beanstalk_common">
<span id="beanmachine-ppl-compiler-beanstalk-common-module"></span><h2>beanmachine.ppl.compiler.beanstalk_common module<a class="headerlink" href="#module-beanmachine.ppl.compiler.beanstalk_common" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-bm-graph-builder-module">
<h2>beanmachine.ppl.compiler.bm_graph_builder module<a class="headerlink" href="#beanmachine-ppl-compiler-bm-graph-builder-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-bm-to-bmg-module">
<h2>beanmachine.ppl.compiler.bm_to_bmg module<a class="headerlink" href="#beanmachine-ppl-compiler-bm-to-bmg-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-bmg-node-types-module">
<h2>beanmachine.ppl.compiler.bmg_node_types module<a class="headerlink" href="#beanmachine-ppl-compiler-bmg-node-types-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-bmg-nodes-module">
<h2>beanmachine.ppl.compiler.bmg_nodes module<a class="headerlink" href="#beanmachine-ppl-compiler-bmg-nodes-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-bmg-requirements-module">
<h2>beanmachine.ppl.compiler.bmg_requirements module<a class="headerlink" href="#beanmachine-ppl-compiler-bmg-requirements-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-beanmachine.ppl.compiler.bmg_types">
<span id="beanmachine-ppl-compiler-bmg-types-module"></span><h2>beanmachine.ppl.compiler.bmg_types module<a class="headerlink" href="#module-beanmachine.ppl.compiler.bmg_types" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.AlwaysMatrix">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">AlwaysMatrix</code><span class="sig-paren">(</span><em>bound: beanmachine.ppl.compiler.bmg_types.BMGMatrixType</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.AlwaysMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BaseRequirement" title="beanmachine.ppl.compiler.bmg_types.BaseRequirement"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BaseRequirement</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.AnyRequirement">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">AnyRequirement</code><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.AnyRequirement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BaseRequirement" title="beanmachine.ppl.compiler.bmg_types.BaseRequirement"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BaseRequirement</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.BMGElementType">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">BMGElementType</code><span class="sig-paren">(</span><em>short_name: str</em>, <em>long_name: str</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.BMGElementType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.BMGLatticeType">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">BMGLatticeType</code><span class="sig-paren">(</span><em>short_name: str</em>, <em>long_name: str</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.BMGLatticeType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.BMGMatrixType">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">BMGMatrixType</code><span class="sig-paren">(</span><em>element_type: beanmachine.ppl.compiler.bmg_types.BMGElementType</em>, <em>short_name: str</em>, <em>long_name: str</em>, <em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.BMGMatrixType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BMGLatticeType" title="beanmachine.ppl.compiler.bmg_types.BMGLatticeType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BMGLatticeType</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.BMGMatrixType.with_dimensions">
<code class="descname">with_dimensions</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.BMGMatrixType.with_dimensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.BMGMatrixType.with_size">
<code class="descname">with_size</code><span class="sig-paren">(</span><em>size: torch.Size</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.BMGMatrixType.with_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.BaseRequirement">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">BaseRequirement</code><span class="sig-paren">(</span><em>short_name: str</em>, <em>long_name: str</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.BaseRequirement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.BooleanMatrix">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">BooleanMatrix</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.BooleanMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType" title="beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.BooleanMatrix.with_dimensions">
<code class="descname">with_dimensions</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.BooleanMatrix.with_dimensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">BroadcastMatrixType</code><span class="sig-paren">(</span><em>element_type: beanmachine.ppl.compiler.bmg_types.BMGElementType</em>, <em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BMGMatrixType" title="beanmachine.ppl.compiler.bmg_types.BMGMatrixType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BMGMatrixType</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.NaturalMatrix">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">NaturalMatrix</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.NaturalMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType" title="beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.NaturalMatrix.with_dimensions">
<code class="descname">with_dimensions</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.NaturalMatrix.with_dimensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.NegativeRealMatrix">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">NegativeRealMatrix</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.NegativeRealMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType" title="beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.NegativeRealMatrix.with_dimensions">
<code class="descname">with_dimensions</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.NegativeRealMatrix.with_dimensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.OneHotMatrix">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">OneHotMatrix</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.OneHotMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BMGMatrixType" title="beanmachine.ppl.compiler.bmg_types.BMGMatrixType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BMGMatrixType</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.OneHotMatrix.with_dimensions">
<code class="descname">with_dimensions</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.OneHotMatrix.with_dimensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.PositiveRealMatrix">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">PositiveRealMatrix</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.PositiveRealMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType" title="beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.PositiveRealMatrix.with_dimensions">
<code class="descname">with_dimensions</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.PositiveRealMatrix.with_dimensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.ProbabilityMatrix">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">ProbabilityMatrix</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.ProbabilityMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType" title="beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.ProbabilityMatrix.with_dimensions">
<code class="descname">with_dimensions</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.ProbabilityMatrix.with_dimensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.RealMatrix">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">RealMatrix</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.RealMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType" title="beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BroadcastMatrixType</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.RealMatrix.with_dimensions">
<code class="descname">with_dimensions</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.RealMatrix.with_dimensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.SimplexMatrix">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">SimplexMatrix</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.SimplexMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BMGMatrixType" title="beanmachine.ppl.compiler.bmg_types.BMGMatrixType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BMGMatrixType</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.SimplexMatrix.with_dimensions">
<code class="descname">with_dimensions</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.SimplexMatrix.with_dimensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="data">
<dt id="beanmachine.ppl.compiler.bmg_types.Untypable">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">Untypable</code><em class="property"> = &lt;beanmachine.ppl.compiler.bmg_types.BMGLatticeType object&gt;</em><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.Untypable" title="Permalink to this definition">¶</a></dt>
<dd><p>When converting from an accumulated graph that uses Python types, we
can express the rules concisely by defining a <em>type lattice</em>. A type
lattice is a DAG which meets these conditions:</p>
<ul class="simple">
<li>Nodes are types</li>
<li>Edges are directed from “larger” types to “smaller” types.
(Note that there is no requirement for a total order.)</li>
<li>There is a function called “supremum” which takes two types
and returns the unique type that is the smallest type that
is bigger than both arguments.</li>
<li>There is a function called “infimum” which similarly is
the unique largest type smaller than both arguments.
(Right now we do not actually need this function in our
type analysis so it is not implemented.)</li>
</ul>
<p>For matrix types with a single column and any number of rows r,
and columns c, the type lattice is:</p>
<blockquote>
<div><blockquote>
<div>T                      (Tensor unsupported by BMG)
|</div></blockquote>
<p>MR[r,c]                  (Real matrix)
|     |
|      MR+[r,c]          (Positive real matrix)</p>
</div></blockquote>
<dl class="docutils">
<dt>MR-[r,c]   |     |           (Negative real matrix)</dt>
<dd><div class="first line-block">
<div class="line-block">
<div class="line">|     |</div>
</div>
<div class="line">MN[r,c]    |           (Natural matrix)</div>
<div class="line-block">
<div class="line-block">
<div class="line">|   MP[r,c]       (Probability matrix)</div>
<div class="line">|   |    |</div>
</div>
<div class="line">MB[r,c]    |        (Boolean matrix)</div>
<div class="line">|    |   S[r,c]     (Row-simplex matrix)</div>
<div class="line">|    |   |</div>
<div class="line">|  OH[r,c]          (One-hot matrix)</div>
<div class="line">|    |</div>
</div>
</div>
<dl class="last docutils">
<dt>Z[r,c]    |              (All-zero matrix)</dt>
<dd><div class="first line-block">
<div class="line"><a href="#id1"><span class="problematic" id="id2">|</span></a></div>
</div>
<p class="last">BOTTOM              (the bottom type)</p>
</dd>
</dl>
</dd>
</dl>
<p>OH – one-hot – is not a type in the BMG type system; we use
it only when analyzing the accumulated graph. The OH type is
used to track the situation where a constant matrix can be
converted to both a Boolean and a simplex matrix; if the
rows are “one hot” – all false (or 0) except for one true
(or 1) – then the matrix is convertable to both Boolean and
simplex.</p>
<p>Similarly, Z – the all-zero matrix – is not a type in the BMG
type system. We use it to track cases where a matrix is convertible
to both Boolean and negative real.</p>
<p>Similarly, T (tensor) – the top type – is not found in the BMG
type system. The top type is the type more general than all other
types, and is used for situations such as attempting to resolve
situations such as “what is the type that is more general than both
a 1x2 matrix and a 2x2 matrix?” or to represent matrix types not
supported in BMG such as 3-dimensional matrices.</p>
<p>The BOTTOM type is the type that has no values; it is similarly
used as a convenience when you need a type more specific than any
other type; it is not in the BMG type system.</p>
<p>Why is this useful?</p>
<p>Our goal is to generate a graph that meets all the requirements of the BMG
type system. In order to do so, we compute a <em>requirement object</em> for each
<em>edge</em> in the graph.</p>
<p>There are two kinds of requirements: “input must be exactly type X” and
“input must be type X or smaller”.  The first kind of requirement we
call an “exact requirement” and the latter is an “upper bound requirement”.</p>
<p>(We do not at this time have any scenarios that need “lower bound
requirements” but if we need them we can add them.)</p>
<p>Once we know the requirements on the <em>incoming</em> edges to a node, we can
check to see if the requirements are met by the nodes.
* If they are, then we’re good.
* If not then we can do a graph mutation which causes the requirements
to be met.
* If there is no such mutation then we can report an error.</p>
<p>How do we compute the requirements for an edge? It depends on the kind
of graph node that the edge is attached to. A Bernoulli node, for example,
requires that its input be “exactly P”. A “to real” node requires
that its input be “R or smaller”.</p>
<p>Some nodes however introduce more complex requirements. The requirements
of a multiplication node, for instance, are:</p>
<ul class="simple">
<li>the input types must be greater than or equal to P</li>
<li>the input types must be exactly the same</li>
</ul>
<p>We do not have a requirement object for either “greater than or equal”, or
for “this edge must be the same as that edge”. And we have one more
factor to throw in: the output type of a multiplication is the same as its
input types, so we wish to find the <em>smallest possible</em> restriction on the
input types so that the multiplication’s type is minimized.</p>
<p>(That is: if we have a multiplication of a natural by a probability, we do
not wish to require that both be converted to reals, because then the
multiplication node could not be used in a context where a positive real
was required. We want the smallest type that works: positive real.)</p>
<p>How are we going to do this?</p>
<p>We generate the edge requirements for a multiplication as follows:</p>
<p>The requirement on both input edges is that they be <em>exactly</em> equal
to the <em>supremum</em> of the <em>infimum types</em> of the two inputs.</p>
<p>The infimum type is the <em>smallest</em> type that each <em>node</em> in the graph
could possibly be. We call this type the “infimum type” of the node
because it is the infimum – the <em>greatest lower bound</em> – in the lattice.</p>
<p>It might not be clear why that works. Let’s work through an example.</p>
<p>Suppose we have a sample from a beta; it’s infimum type is Probability because
that’s the only type a sample from a beta can be.  And suppose we have a sample
from a binomial; it’s infimum type is Natural, again, because that’s the only
type it can be.</p>
<p>Now suppose we multiply them. What restrictions go on the left and right
input edges of the multiplication?</p>
<p>The supremum of Natural and Probability is PositiveReal, so we put an “exactly
PositiveReal” restriction on the two edges. During the “fix problems” phase,
we see that we have an edge from a multiplication to a sample of type Probability,
but there is a requirement that it be a PositiveReal, so we insert a
ToPositiveRealNode between the multiplication and the sample. And then similarly
for the sample of type Natural.</p>
<p>The result is that we have a multiplication node that meets its requirements;
the input types are the same, and the output type is the smallest type it
could possibly be: PositiveReal.</p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.UpperBound">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">UpperBound</code><span class="sig-paren">(</span><em>bound: beanmachine.ppl.compiler.bmg_types.BMGLatticeType</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.UpperBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BaseRequirement" title="beanmachine.ppl.compiler.bmg_types.BaseRequirement"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BaseRequirement</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.bmg_types.ZeroMatrix">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">ZeroMatrix</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.ZeroMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.bmg_types.BMGMatrixType" title="beanmachine.ppl.compiler.bmg_types.BMGMatrixType"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.bmg_types.BMGMatrixType</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.bmg_types.ZeroMatrix.with_dimensions">
<code class="descname">with_dimensions</code><span class="sig-paren">(</span><em>rows: int</em>, <em>columns: int</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGMatrixType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.ZeroMatrix.with_dimensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.bmg_types.always_matrix">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">always_matrix</code><span class="sig-paren">(</span><em>bound: beanmachine.ppl.compiler.bmg_types.BMGMatrixType</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.bmg_types.BMGLatticeType, beanmachine.ppl.compiler.bmg_types.BaseRequirement]<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.always_matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.bmg_types.is_atomic">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">is_atomic</code><span class="sig-paren">(</span><em>t: beanmachine.ppl.compiler.bmg_types.BMGLatticeType</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.is_atomic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.bmg_types.is_convertible_to">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">is_convertible_to</code><span class="sig-paren">(</span><em>source: beanmachine.ppl.compiler.bmg_types.BMGLatticeType</em>, <em>target: beanmachine.ppl.compiler.bmg_types.BMGLatticeType</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.is_convertible_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.bmg_types.is_one">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">is_one</code><span class="sig-paren">(</span><em>v: Any</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.is_one" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.bmg_types.is_zero">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">is_zero</code><span class="sig-paren">(</span><em>v: Any</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.is_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.bmg_types.must_be_matrix">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">must_be_matrix</code><span class="sig-paren">(</span><em>r: Union[beanmachine.ppl.compiler.bmg_types.BMGLatticeType, beanmachine.ppl.compiler.bmg_types.BaseRequirement]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.must_be_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the requirement indicate that the edge must be a matrix?</p>
</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.bmg_types.requirement_to_type">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">requirement_to_type</code><span class="sig-paren">(</span><em>r: Union[beanmachine.ppl.compiler.bmg_types.BMGLatticeType, beanmachine.ppl.compiler.bmg_types.BaseRequirement]</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGLatticeType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.requirement_to_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.bmg_types.supremum">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">supremum</code><span class="sig-paren">(</span><em>*ts</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGLatticeType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.supremum" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes any number of BMG types; returns the smallest type that is
greater than or equal to all of them.</p>
</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.bmg_types.type_of_value">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">type_of_value</code><span class="sig-paren">(</span><em>v: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BMGLatticeType<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.type_of_value" title="Permalink to this definition">¶</a></dt>
<dd><p>This computes the smallest BMG type that a given value fits into.</p>
</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.bmg_types.upper_bound">
<code class="descclassname">beanmachine.ppl.compiler.bmg_types.</code><code class="descname">upper_bound</code><span class="sig-paren">(</span><em>bound: Union[beanmachine.ppl.compiler.bmg_types.BMGLatticeType, beanmachine.ppl.compiler.bmg_types.BaseRequirement]</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.bmg_types.BaseRequirement<a class="headerlink" href="#beanmachine.ppl.compiler.bmg_types.upper_bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="beanmachine-ppl-compiler-error-report-module">
<h2>beanmachine.ppl.compiler.error_report module<a class="headerlink" href="#beanmachine-ppl-compiler-error-report-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-fix-additions-module">
<h2>beanmachine.ppl.compiler.fix_additions module<a class="headerlink" href="#beanmachine-ppl-compiler-fix-additions-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-fix-bool-arithmetic-module">
<h2>beanmachine.ppl.compiler.fix_bool_arithmetic module<a class="headerlink" href="#beanmachine-ppl-compiler-fix-bool-arithmetic-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-fix-bool-comparisons-module">
<h2>beanmachine.ppl.compiler.fix_bool_comparisons module<a class="headerlink" href="#beanmachine-ppl-compiler-fix-bool-comparisons-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-fix-multiary-ops-module">
<h2>beanmachine.ppl.compiler.fix_multiary_ops module<a class="headerlink" href="#beanmachine-ppl-compiler-fix-multiary-ops-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-fix-observations-module">
<h2>beanmachine.ppl.compiler.fix_observations module<a class="headerlink" href="#beanmachine-ppl-compiler-fix-observations-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-fix-observe-true-module">
<h2>beanmachine.ppl.compiler.fix_observe_true module<a class="headerlink" href="#beanmachine-ppl-compiler-fix-observe-true-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-fix-problem-module">
<h2>beanmachine.ppl.compiler.fix_problem module<a class="headerlink" href="#beanmachine-ppl-compiler-fix-problem-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-fix-problems-module">
<h2>beanmachine.ppl.compiler.fix_problems module<a class="headerlink" href="#beanmachine-ppl-compiler-fix-problems-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-fix-requirements-module">
<h2>beanmachine.ppl.compiler.fix_requirements module<a class="headerlink" href="#beanmachine-ppl-compiler-fix-requirements-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-fix-unsupported-module">
<h2>beanmachine.ppl.compiler.fix_unsupported module<a class="headerlink" href="#beanmachine-ppl-compiler-fix-unsupported-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-gen-bmg-cpp-module">
<h2>beanmachine.ppl.compiler.gen_bmg_cpp module<a class="headerlink" href="#beanmachine-ppl-compiler-gen-bmg-cpp-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-gen-bmg-graph-module">
<h2>beanmachine.ppl.compiler.gen_bmg_graph module<a class="headerlink" href="#beanmachine-ppl-compiler-gen-bmg-graph-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-gen-bmg-python-module">
<h2>beanmachine.ppl.compiler.gen_bmg_python module<a class="headerlink" href="#beanmachine-ppl-compiler-gen-bmg-python-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-gen-builder-module">
<h2>beanmachine.ppl.compiler.gen_builder module<a class="headerlink" href="#beanmachine-ppl-compiler-gen-builder-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-gen-dot-module">
<h2>beanmachine.ppl.compiler.gen_dot module<a class="headerlink" href="#beanmachine-ppl-compiler-gen-dot-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-graph-labels-module">
<h2>beanmachine.ppl.compiler.graph_labels module<a class="headerlink" href="#beanmachine-ppl-compiler-graph-labels-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-beanmachine.ppl.compiler.hint">
<span id="beanmachine-ppl-compiler-hint-module"></span><h2>beanmachine.ppl.compiler.hint module<a class="headerlink" href="#module-beanmachine.ppl.compiler.hint" title="Permalink to this headline">¶</a></h2>
<p>Operations that are intended as hints to the Beanstalk compiler</p>
<dl class="function">
<dt id="beanmachine.ppl.compiler.hint.log1mexp">
<code class="descclassname">beanmachine.ppl.compiler.hint.</code><code class="descname">log1mexp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.hint.log1mexp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.hint.math_log1mexp">
<code class="descclassname">beanmachine.ppl.compiler.hint.</code><code class="descname">math_log1mexp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.hint.math_log1mexp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="beanmachine-ppl-compiler-internal-error-module">
<h2>beanmachine.ppl.compiler.internal_error module<a class="headerlink" href="#beanmachine-ppl-compiler-internal-error-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="beanmachine-ppl-compiler-lattice-typer-module">
<h2>beanmachine.ppl.compiler.lattice_typer module<a class="headerlink" href="#beanmachine-ppl-compiler-lattice-typer-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-beanmachine.ppl.compiler.patterns">
<span id="beanmachine-ppl-compiler-patterns-module"></span><h2>beanmachine.ppl.compiler.patterns module<a class="headerlink" href="#module-beanmachine.ppl.compiler.patterns" title="Permalink to this headline">¶</a></h2>
<p>A pattern matching engine</p>
<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.AnyPattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">AnyPattern</code><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.AnyPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>The pattern that matches anything; it always succeeds.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.AnyPattern.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.AnyPattern.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.AtomicPattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">AtomicPattern</code><span class="sig-paren">(</span><em>value: Union[bool, int, float, str, None]</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.AtomicPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>An atomic pattern matches against a single specific value, such as a
specific integer, Boolean, string, and so on.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.AtomicPattern.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.AtomicPattern.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.AttributeSubpattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">AttributeSubpattern</code><span class="sig-paren">(</span><em>name: str, subpattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.AttributeSubpattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>Sometimes we want to check to see if an attribute of a value matches
a pattern. This class represents such patterns. It takes a subpattern and
an attribute name. When match is called, it runs the subpattern on the
attribute of the given value.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.AttributeSubpattern.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.AttributeSubpattern.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.BoolPattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">BoolPattern</code><span class="sig-paren">(</span><em>value: bool</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.BoolPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.AtomicPattern" title="beanmachine.ppl.compiler.patterns.AtomicPattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.AtomicPattern</span></code></a></p>
<p>The pattern that matches a specific Boolean value.</p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.EmptyListPattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">EmptyListPattern</code><span class="sig-paren">(</span><em>name: str = 'empty_list'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.EmptyListPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>This pattern matches an empty list.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.EmptyListPattern.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.EmptyListPattern.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.Fail">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">Fail</code><span class="sig-paren">(</span><em>test: Any = None</em>, <em>submatches: Optional[Dict[str</em>, <em>beanmachine.ppl.compiler.patterns.MatchResult]] = None</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.Fail" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.MatchResult" title="beanmachine.ppl.compiler.patterns.MatchResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.MatchResult</span></code></a></p>
<p>A pattern that always fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.Fail.is_fail">
<code class="descname">is_fail</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.Fail.is_fail" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.Fail.is_success">
<code class="descname">is_success</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.Fail.is_success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.FailPattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">FailPattern</code><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.FailPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>The pattern that matches nothing; it always fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.FailPattern.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.FailPattern.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.FloatPattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">FloatPattern</code><span class="sig-paren">(</span><em>value: float</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.FloatPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.AtomicPattern" title="beanmachine.ppl.compiler.patterns.AtomicPattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.AtomicPattern</span></code></a></p>
<p>The pattern that matches a specific float value.</p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.HeadTail">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">HeadTail</code><span class="sig-paren">(</span><em>head: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>tail: Union[beanmachine.ppl.compiler.patterns.PatternBase</em>, <em>int</em>, <em>str</em>, <em>float</em>, <em>type</em>, <em>list</em>, <em>None] = &lt;beanmachine.ppl.compiler.patterns.AnyPattern object&gt;</em>, <em>name: str = 'head_tail'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.HeadTail" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>This combinator takes a pattern to match the head of a list and
a pattern to match the tail. If the list is empty, it automatically
fails; otherwise both patterns must match.  The tail pattern is not
attempted if the head pattern fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.HeadTail.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.HeadTail.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.IntPattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">IntPattern</code><span class="sig-paren">(</span><em>value: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.IntPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.AtomicPattern" title="beanmachine.ppl.compiler.patterns.AtomicPattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.AtomicPattern</span></code></a></p>
<p>The pattern that matches a specific integer value.</p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.ListAll">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">ListAll</code><span class="sig-paren">(</span><em>pattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None], name: str = 'list_all'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.ListAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>Matches a list where all elements of the list match the pattern.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.ListAll.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.ListAll.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.ListAny">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">ListAny</code><span class="sig-paren">(</span><em>pattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None], name: str = 'list_any'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.ListAny" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>Matches a list where one or more elements of the list match the pattern.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.ListAny.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.ListAny.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.ListPattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">ListPattern</code><span class="sig-paren">(</span><em>patterns: List[Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]], name: str = 'list_pattern'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.ListPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>This pattern matches a list of patterns to a list.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.ListPattern.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.ListPattern.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.MatchAny">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">MatchAny</code><span class="sig-paren">(</span><em>*patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.MatchAny" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>The pattern that succeeds if any pattern in the list succeeds.
It will stop trying to match patterns after the first success. If there
are no patterns in the list then it fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.MatchAny.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.MatchAny.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.MatchEvery">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">MatchEvery</code><span class="sig-paren">(</span><em>*patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.MatchEvery" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>The pattern that succeeds if every pattern in the list succeeds.
It will stop trying to match patterns after the first failure. If there
are no patterns in the list then it succeeds.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.MatchEvery.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.MatchEvery.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.MatchResult">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">MatchResult</code><span class="sig-paren">(</span><em>test: Any</em>, <em>submatches: Optional[Dict[str</em>, <em>MatchResult]] = None</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.MatchResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>The result of a pattern match; either success or failure.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.MatchResult.is_fail">
<code class="descname">is_fail</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.MatchResult.is_fail" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.MatchResult.is_success">
<code class="descname">is_success</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.MatchResult.is_success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.Negate">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">Negate</code><span class="sig-paren">(</span><em>pattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.Negate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>Negates a pattern; if the underlying pattern succeeds, this fails, and
vice versa.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.Negate.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.Negate.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.NonePattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">NonePattern</code><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.NonePattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.AtomicPattern" title="beanmachine.ppl.compiler.patterns.AtomicPattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.AtomicPattern</span></code></a></p>
<p>The pattern that matches None.</p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.PatternBase">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">PatternBase</code><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.PatternBase.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.PatternBase.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.PredicatePattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">PredicatePattern</code><span class="sig-paren">(</span><em>predicate: Callable[[Any], bool], name: str = 'if'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.PredicatePattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>A pattern is logically a predicate; this pattern just encapsulates any
predicate that returns a match result.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.PredicatePattern.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.PredicatePattern.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.StringPattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">StringPattern</code><span class="sig-paren">(</span><em>value: str</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.StringPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.AtomicPattern" title="beanmachine.ppl.compiler.patterns.AtomicPattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.AtomicPattern</span></code></a></p>
<p>The pattern that matches a specific string value.</p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.Subpattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">Subpattern</code><span class="sig-paren">(</span><em>name: str, subpattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None], get_subtest: Callable[[Any], Any]</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.Subpattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>Sometimes we want to check to see if a given value matches the pattern
whereby some projected value matches a pattern. This class represents
such patterns. It takes a subpattern and a projection; when match is called,
it projects the value and runs the subpattern on the projected value.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.Subpattern.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.Subpattern.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.Success">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">Success</code><span class="sig-paren">(</span><em>test: Any = None</em>, <em>submatches: Optional[Dict[str</em>, <em>beanmachine.ppl.compiler.patterns.MatchResult]] = None</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.Success" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.MatchResult" title="beanmachine.ppl.compiler.patterns.MatchResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.MatchResult</span></code></a></p>
<p>A pattern that always succeeds.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.Success.is_fail">
<code class="descname">is_fail</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.Success.is_fail" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.Success.is_success">
<code class="descname">is_success</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.Success.is_success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.patterns.TypePattern">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">TypePattern</code><span class="sig-paren">(</span><em>typ: type</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.patterns.TypePattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.patterns.PatternBase" title="beanmachine.ppl.compiler.patterns.PatternBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.patterns.PatternBase</span></code></a></p>
<p>The pattern that matches if the value is an instance of the given type.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.patterns.TypePattern.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.TypePattern.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.patterns.attribute">
<code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">attribute</code><span class="sig-paren">(</span><em>name: str, subpattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.attribute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.patterns.is_any">
<code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">is_any</code><span class="sig-paren">(</span><em>pattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.is_any" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.patterns.match">
<code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">match</code><span class="sig-paren">(</span><em>pattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None], test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.MatchResult<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.patterns.match_any">
<code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">match_any</code><span class="sig-paren">(</span><em>*patterns</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.match_any" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.patterns.match_every">
<code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">match_every</code><span class="sig-paren">(</span><em>*patterns</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.match_every" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.patterns.negate">
<code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">negate</code><span class="sig-paren">(</span><em>pattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.negate" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces the negation of a given pattern.</p>
</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.patterns.to_pattern">
<code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">to_pattern</code><span class="sig-paren">(</span><em>pattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.patterns.PatternBase<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.to_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes any value that can be used as a pattern, and returns an object that
derives from PatternBase that has the same semantics.</p>
</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.patterns.type_and_attributes">
<code class="descclassname">beanmachine.ppl.compiler.patterns.</code><code class="descname">type_and_attributes</code><span class="sig-paren">(</span><em>typ: type, patterns: Dict[str, Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]]</em><span class="sig-paren">)</span> &#x2192; Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None]<a class="headerlink" href="#beanmachine.ppl.compiler.patterns.type_and_attributes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-beanmachine.ppl.compiler.performance_report">
<span id="beanmachine-ppl-compiler-performance-report-module"></span><h2>beanmachine.ppl.compiler.performance_report module<a class="headerlink" href="#module-beanmachine.ppl.compiler.performance_report" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="beanmachine.ppl.compiler.performance_report.PerformanceReport">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.performance_report.</code><code class="descname">PerformanceReport</code><a class="headerlink" href="#beanmachine.ppl.compiler.performance_report.PerformanceReport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="beanmachine.ppl.compiler.performance_report.PerformanceReport.json">
<code class="descname">json</code><em class="property"> = None</em><a class="headerlink" href="#beanmachine.ppl.compiler.performance_report.PerformanceReport.json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.performance_report.json_to_perf_report">
<code class="descclassname">beanmachine.ppl.compiler.performance_report.</code><code class="descname">json_to_perf_report</code><span class="sig-paren">(</span><em>json: str</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.performance_report.PerformanceReport<a class="headerlink" href="#beanmachine.ppl.compiler.performance_report.json_to_perf_report" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-beanmachine.ppl.compiler.profiler">
<span id="beanmachine-ppl-compiler-profiler-module"></span><h2>beanmachine.ppl.compiler.profiler module<a class="headerlink" href="#module-beanmachine.ppl.compiler.profiler" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="beanmachine.ppl.compiler.profiler.Event">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.profiler.</code><code class="descname">Event</code><span class="sig-paren">(</span><em>begin: bool</em>, <em>kind: str</em>, <em>timestamp: int</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.profiler.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.profiler.ProfileReport">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.profiler.</code><code class="descname">ProfileReport</code><a class="headerlink" href="#beanmachine.ppl.compiler.profiler.ProfileReport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.profiler.ProfilerData">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.profiler.</code><code class="descname">ProfilerData</code><a class="headerlink" href="#beanmachine.ppl.compiler.profiler.ProfilerData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.profiler.ProfilerData.begin">
<code class="descname">begin</code><span class="sig-paren">(</span><em>kind: str</em>, <em>timestamp: Optional[int] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#beanmachine.ppl.compiler.profiler.ProfilerData.begin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.profiler.ProfilerData.finish">
<code class="descname">finish</code><span class="sig-paren">(</span><em>kind: str</em>, <em>timestamp: Optional[int] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#beanmachine.ppl.compiler.profiler.ProfilerData.finish" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.profiler.ProfilerData.time_in">
<code class="descname">time_in</code><span class="sig-paren">(</span><em>kind: str</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#beanmachine.ppl.compiler.profiler.ProfilerData.time_in" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.profiler.ProfilerData.to_report">
<code class="descname">to_report</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.profiler.ProfileReport<a class="headerlink" href="#beanmachine.ppl.compiler.profiler.ProfilerData.to_report" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.profiler.event_list_to_report">
<code class="descclassname">beanmachine.ppl.compiler.profiler.</code><code class="descname">event_list_to_report</code><span class="sig-paren">(</span><em>events</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.profiler.ProfileReport<a class="headerlink" href="#beanmachine.ppl.compiler.profiler.event_list_to_report" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-beanmachine.ppl.compiler.rules">
<span id="beanmachine-ppl-compiler-rules-module"></span><h2>beanmachine.ppl.compiler.rules module<a class="headerlink" href="#module-beanmachine.ppl.compiler.rules" title="Permalink to this headline">¶</a></h2>
<p>A rules engine for tree transformation</p>
<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.AllChildren">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">AllChildren</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule, get_children: Callable[[Any], Dict[str, Any]], construct: Callable[[type, Dict[str, Any]], Any], name: str = 'all_children'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply a rule to all children or list members.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.AllChildren.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllChildren.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.AllChildren.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllChildren.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.AllListEditMembers">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">AllListEditMembers</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'all_list_edit_members'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllListEditMembers" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Rules which are intended to modify a parent list by adding or removing items
return a ListEdit([…]) object, but in cases where a rule then recursese
upon children – like top_down – we’ll potentially need to rewrite the elements
in edit list. This combinator implements that.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.AllListEditMembers.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllListEditMembers.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.AllListEditMembers.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllListEditMembers.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.AllListMembers">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">AllListMembers</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'all_list_members'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllListMembers" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply a rule to all members.  Succeeds if the rule succeeds for all members,
and returns a list with the members replaced with the new values.
Otherwise, fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.AllListMembers.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllListMembers.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.AllListMembers.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllListMembers.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.AllOf">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">AllOf</code><span class="sig-paren">(</span><em>rules: List[beanmachine.ppl.compiler.rules.Rule], name: str = 'all_of'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Takes a list of rules and composes together all of them.
All must succeed, otherwise the rule fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.AllOf.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllOf.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.AllOf.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllOf.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.AllTermChildren">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">AllTermChildren</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule, get_children: Callable[[Any], Dict[str, Any]], construct: Callable[[type, Dict[str, Any]], Any], name: str = 'all_children'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllTermChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply a rule to all children.  Succeeds if the rule succeeds for all children,
and returns a constructed object with the children replaced with the new values.
Otherwise, fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.AllTermChildren.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllTermChildren.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.AllTermChildren.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.AllTermChildren.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.Check">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">Check</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'check'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.Check" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply the given rule; if it fails, fail. If it succeeds, the result
is the original test value, not the transformed value.  This is useful
for scenarios where we wish to know if a particular thing is true of
a node before we apply an expensive rule to it.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Check.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Check.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Check.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Check.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.Choose">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">Choose</code><span class="sig-paren">(</span><em>condition: beanmachine.ppl.compiler.rules.Rule</em>, <em>consequence: beanmachine.ppl.compiler.rules.Rule</em>, <em>alternative: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'choose'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.Choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply the condition rule to the test.
If it succeeds, apply the rule in the consequence to its output.
If it fails, apply the rule in the alternative to the test.
That is, Choose(a, b, c)(test) has the semantics of
if a(test) then b(a(test)) else c(test)</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Choose.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Choose.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Choose.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Choose.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.Compose">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">Compose</code><span class="sig-paren">(</span><em>first: beanmachine.ppl.compiler.rules.Rule</em>, <em>second: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'compose'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.Compose" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply the first rule to the test.
If it succeeds, apply the second rule to its output.
That is, Compose(a, b)(test) has the semantics of
if a(test) then b(a(test)) else fail</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Compose.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Compose.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Compose.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Compose.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.Fail">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">Fail</code><span class="sig-paren">(</span><em>test: Any = None</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.Fail" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.RuleResult" title="beanmachine.ppl.compiler.rules.RuleResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.RuleResult</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Fail.expect_success">
<code class="descname">expect_success</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Any<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Fail.expect_success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Fail.is_fail">
<code class="descname">is_fail</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Fail.is_fail" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Fail.is_success">
<code class="descname">is_success</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Fail.is_success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.FirstMatch">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">FirstMatch</code><span class="sig-paren">(</span><em>rules: Iterable[beanmachine.ppl.compiler.rules.Rule], name: str = 'first_match'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.FirstMatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply each rule to the test until one succeeds; if none succeed, then fail.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.FirstMatch.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.FirstMatch.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.FirstMatch.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.FirstMatch.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.IgnoreException">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">IgnoreException</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule, expected: List[type] = [&lt;class 'Exception'&gt;], name: str = 'handle'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.IgnoreException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply the given rule; if it throws an exception, the rule fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.IgnoreException.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.IgnoreException.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.IgnoreException.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.IgnoreException.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.ListEdit">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">ListEdit</code><span class="sig-paren">(</span><em>edits: List[Any]</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.ListEdit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Consider a rule which descends through an AST looking for a particular
statement to replace. If the rule replaces a particular statement with
another statement, we can express that with a straightforward rule that
succeeds and produces the new statement. But how can we represent rules that
either delete a statement (that is, replace it with nothing) or replace it
with more than one statement?
To express this concept, a rule should succeed and return a ListEdit([s1, s2…])
where the list contains the replacements; if the list is empty then the
element is deleted.</p>
</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.OneChild">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">OneChild</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule, get_children: Callable[[Any], Dict[str, Any]], construct: Callable[[type, Dict[str, Any]], Any], name: str = 'one_child'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.OneChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply a rule to all children until the first success.  Succeeds if it
finds one success and returns a constructed object with the child replaced
with the new value. Otherwise, fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.OneChild.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.OneChild.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.OneChild.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.OneChild.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.OneListMember">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">OneListMember</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'one_child'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.OneListMember" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply a rule to all members until the first success.  Succeeds if it
finds one success and returns a list with the child replaced
with the new value. Otherwise, fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.OneListMember.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.OneListMember.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.OneListMember.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.OneListMember.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.OrElse">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">OrElse</code><span class="sig-paren">(</span><em>first: beanmachine.ppl.compiler.rules.Rule</em>, <em>second: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'or_else'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.OrElse" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply the first rule to the test.
If it succeeds, use that result.
If it fails, apply the second rule to the test and return that.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.OrElse.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.OrElse.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.OrElse.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.OrElse.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.PatternRule">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">PatternRule</code><span class="sig-paren">(</span><em>pattern: Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None], projection: Callable[[Any], Any] = &lt;function _identity&gt;, name: str = 'pattern'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.PatternRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>If the test value matches the pattern, then the test value is passed
to the projection and the rule succeeds. Otherwise, the rule fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.PatternRule.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.PatternRule.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.PatternRule.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.PatternRule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.Recursive">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">Recursive</code><span class="sig-paren">(</span><em>rule_maker: Callable[[], beanmachine.ppl.compiler.rules.Rule], name: str = 'recursive'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.Recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Delay construction of a rule until we need it, so as to avoid recursion.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Recursive.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Recursive.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Recursive.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Recursive.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.Rule">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">Rule</code><span class="sig-paren">(</span><em>name: str = ''</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.Rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>A rule represents a partial function that transforms a value.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Rule.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Rule.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Rule.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Rule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">RuleDomain</code><span class="sig-paren">(</span><em>get_children: Callable[[Any], Dict[str, Any]], construct: Callable[[type, Dict[str, Any]], Any]</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain.all_children">
<code class="descname">all_children</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'all_children'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain.all_children" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain.bottom_up">
<code class="descname">bottom_up</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'bottom_up'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain.bottom_up" title="Permalink to this definition">¶</a></dt>
<dd><p>The bottom-up combinator applies a rule to all leaves, then to the rewritten
parent, and so on up to the root.</p>
</dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain.descend_until">
<code class="descname">descend_until</code><span class="sig-paren">(</span><em>test: beanmachine.ppl.compiler.rules.Rule</em>, <em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'descend_until'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain.descend_until" title="Permalink to this definition">¶</a></dt>
<dd><p>descend_until starts at the top of the tree and descends down it
checking every node to see if “test” succeeds. If it does, it stops
descending and runs “rule” on that node. It does this on every node
that meets the test starting from the root.</p>
</dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain.down_then_up">
<code class="descname">down_then_up</code><span class="sig-paren">(</span><em>pre_rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>post_rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'down_then_up'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain.down_then_up" title="Permalink to this definition">¶</a></dt>
<dd><p>The down-then-up combinator is a combination of the bottom-up and
top-down combinators; it applies the ‘pre’ rule in a top-down traversal
and then the ‘post’ rule on the way back up.</p>
</dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain.one_child">
<code class="descname">one_child</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'one_child'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain.one_child" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain.some_bottom_up">
<code class="descname">some_bottom_up</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'some_bottom_up'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain.some_bottom_up" title="Permalink to this definition">¶</a></dt>
<dd><p>The some-bottom-up combinator is like bottom_up, in that it applies a
rule to every node in the tree starting from the leaves. However, bottom_up
requires that the rule succeed for all nodes in the tree; some_bottom_up
applies the rule to as many nodes in the tree as possible, leaves alone
nodes for which it fails, and fails only if the rule applied to no node.</p>
</dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain.some_children">
<code class="descname">some_children</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'some_children'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain.some_children" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain.some_top_down">
<code class="descname">some_top_down</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'some_top_down'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain.some_top_down" title="Permalink to this definition">¶</a></dt>
<dd><p>The some-top-down combinator is like top_down, in that it applies a
rule to every node in the tree starting from the top. However, top_down
requires that the rule succeed for all nodes in the tree; some_top_down
applies the rule to as many nodes in the tree as possible, leaves alone
nodes for which it fails (aside from possibly rewriting the children),
and fails only if the rule applied to no node.</p>
</dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain.specific_child">
<code class="descname">specific_child</code><span class="sig-paren">(</span><em>child: str</em>, <em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'specific_child'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain.specific_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a rule to a specific child.  If it succeeds, replace the child
with the new value; otherwise, fail. The child is required to exist.</p>
</dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleDomain.top_down">
<code class="descname">top_down</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'top_down'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleDomain.top_down" title="Permalink to this definition">¶</a></dt>
<dd><p>The top-down combinator applies a rule to the root, then to the new root’s
children, and so on down to the leaves. It succeeds iff the rule succeeds on
every node.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.RuleResult">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">RuleResult</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleResult.expect_success">
<code class="descname">expect_success</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Any<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleResult.expect_success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleResult.is_fail">
<code class="descname">is_fail</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleResult.is_fail" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.RuleResult.is_success">
<code class="descname">is_success</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.RuleResult.is_success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.SomeChildren">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">SomeChildren</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule, get_children: Callable[[Any], Dict[str, Any]], construct: Callable[[type, Dict[str, Any]], Any], name: str = 'some_children'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.SomeChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply a rule to all children.  Succeeds if the rule succeeds for one or
more children, and returns a constructed object with the children replaced
with the new values. Otherwise, fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.SomeChildren.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.SomeChildren.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.SomeChildren.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.SomeChildren.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.SomeListMembers">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">SomeListMembers</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'some_list_members'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.SomeListMembers" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply a rule to all members.  Succeeds if the rule succeeds for one or
more members, and returns a list with the children replaced
with the new values. Otherwise, fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.SomeListMembers.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.SomeListMembers.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.SomeListMembers.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.SomeListMembers.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.SomeOf">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">SomeOf</code><span class="sig-paren">(</span><em>rules: List[beanmachine.ppl.compiler.rules.Rule], name: str = 'some_of'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.SomeOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Takes a list of rules and composes together as many of them as succeed.
At least one must succeed, otherwise the rule fails.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.SomeOf.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.SomeOf.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.SomeOf.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.SomeOf.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.SpecificChild">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">SpecificChild</code><span class="sig-paren">(</span><em>child: str, rule: beanmachine.ppl.compiler.rules.Rule, get_children: Callable[[Any], Dict[str, Any]], construct: Callable[[type, Dict[str, Any]], Any], name: str = 'specific_child'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.SpecificChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply a rule to a specific child.  If it succeeds, replace the child
with the new value; otherwise, fail. The child is required to exist.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.SpecificChild.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.SpecificChild.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.SpecificChild.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.SpecificChild.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.Success">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">Success</code><span class="sig-paren">(</span><em>test: Any</em>, <em>result: Any</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.Success" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.RuleResult" title="beanmachine.ppl.compiler.rules.RuleResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.RuleResult</span></code></a></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Success.expect_success">
<code class="descname">expect_success</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Any<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Success.expect_success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Success.is_fail">
<code class="descname">is_fail</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Success.is_fail" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Success.is_success">
<code class="descname">is_success</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Success.is_success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.Trace">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">Trace</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule, logger: Callable[[beanmachine.ppl.compiler.rules.Rule, Any], None]</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.Trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>This combinator introduces a side effect to be executed every time the
child rule is executed, and when it succeeds or fails. It is useful for
debugging.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Trace.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Trace.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.Trace.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.Trace.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.TryMany">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">TryMany</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'try_many'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.TryMany" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Repeatedly apply a rule; the result is that of the last application
that succeeded, or the original test if none succeeded.
This rule always succeeds.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.TryMany.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.TryMany.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.TryMany.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.TryMany.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="beanmachine.ppl.compiler.rules.TryOnce">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">TryOnce</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'try_once'</em><span class="sig-paren">)</span><a class="headerlink" href="#beanmachine.ppl.compiler.rules.TryOnce" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#beanmachine.ppl.compiler.rules.Rule" title="beanmachine.ppl.compiler.rules.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">beanmachine.ppl.compiler.rules.Rule</span></code></a></p>
<p>Apply the rule to the test.
If it succeeds, use that result.
If it fails, use the test as the result and succeed.
This rule always succeeds.</p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.TryOnce.always_succeeds">
<code class="descname">always_succeeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#beanmachine.ppl.compiler.rules.TryOnce.always_succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.rules.TryOnce.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>test: Any</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.RuleResult<a class="headerlink" href="#beanmachine.ppl.compiler.rules.TryOnce.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.always_replace">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">always_replace</code><span class="sig-paren">(</span><em>value: Any</em>, <em>name: str = 'always_replace'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.always_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>always_replace(value) produces a rule that replaces anything with
the given value. It always succeeds.</p>
</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.at_least_once">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">at_least_once</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.at_least_once" title="Permalink to this definition">¶</a></dt>
<dd><p>Try a rule once; if it fails, fail. If it succeeds,
try it again as many times as it keeps succeeding.</p>
</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.either_or_both">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">either_or_both</code><span class="sig-paren">(</span><em>first: beanmachine.ppl.compiler.rules.Rule</em>, <em>second: beanmachine.ppl.compiler.rules.Rule</em>, <em>name: str = 'either_or_both'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.either_or_both" title="Permalink to this definition">¶</a></dt>
<dd><p>Do the first rule; if it succeeds, try doing the second rule, but do
not worry if it fails. If the first rule fails, do the second rule. The
net effect is, either first, or second, or first-then-second happens,
or both fail.</p>
</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.if_then">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">if_then</code><span class="sig-paren">(</span><em>condition: beanmachine.ppl.compiler.rules.Rule</em>, <em>consequence: beanmachine.ppl.compiler.rules.Rule</em>, <em>alternative: beanmachine.ppl.compiler.rules.Rule = &lt;beanmachine.ppl.compiler.rules.PatternRule object&gt;</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.if_then" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the condition rule, then apply the original test to either the
consequence or the alternative, depending on whether the condition succeeded
or failed. Note that this is different than Choose. Choose applies the
condition to the result of the condition, not to the original test.</p>
</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.ignore_div_zero">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">ignore_div_zero</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.ignore_div_zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.ignore_runtime_error">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">ignore_runtime_error</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.ignore_runtime_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.ignore_value_error">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">ignore_value_error</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.ignore_value_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.list_member_children">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">list_member_children</code><span class="sig-paren">(</span><em>rule: beanmachine.ppl.compiler.rules.Rule</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.list_member_children" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.make_logger">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">make_logger</code><span class="sig-paren">(</span><em>log: List[str]</em><span class="sig-paren">)</span> &#x2192; Callable[[beanmachine.ppl.compiler.rules.Rule], beanmachine.ppl.compiler.rules.Rule]<a class="headerlink" href="#beanmachine.ppl.compiler.rules.make_logger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.pattern_rules">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">pattern_rules</code><span class="sig-paren">(</span><em>pairs: List[Tuple[Union[beanmachine.ppl.compiler.patterns.PatternBase, int, str, float, type, list, None], Callable[[Any], Any]]], name: str = 'pattern_rules'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.pattern_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a rule from a sequence of pairs of patterns and projections.
Patterns are checked in order, and the first one that matches is used for the
projection; if none match then the rule fails.</p>
</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.rules.projection_rule">
<code class="descclassname">beanmachine.ppl.compiler.rules.</code><code class="descname">projection_rule</code><span class="sig-paren">(</span><em>projection: Callable[[Any], Any], name: str = 'projection'</em><span class="sig-paren">)</span> &#x2192; beanmachine.ppl.compiler.rules.Rule<a class="headerlink" href="#beanmachine.ppl.compiler.rules.projection_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="beanmachine-ppl-compiler-runtime-module">
<h2>beanmachine.ppl.compiler.runtime module<a class="headerlink" href="#beanmachine-ppl-compiler-runtime-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-beanmachine.ppl.compiler.single_assignment">
<span id="beanmachine-ppl-compiler-single-assignment-module"></span><h2>beanmachine.ppl.compiler.single_assignment module<a class="headerlink" href="#module-beanmachine.ppl.compiler.single_assignment" title="Permalink to this headline">¶</a></h2>
<p>Tools to transform Bean Machine programs to Bean Machine Graph</p>
<dl class="class">
<dt id="beanmachine.ppl.compiler.single_assignment.SingleAssignment">
<em class="property">class </em><code class="descclassname">beanmachine.ppl.compiler.single_assignment.</code><code class="descname">SingleAssignment</code><a class="headerlink" href="#beanmachine.ppl.compiler.single_assignment.SingleAssignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="beanmachine.ppl.compiler.single_assignment.SingleAssignment.fresh_names">
<code class="descname">fresh_names</code><span class="sig-paren">(</span><em>prefix_list: List[str], builder: Callable[[Callable[[str, str], _ast.Name]], Any]</em><span class="sig-paren">)</span> &#x2192; Any<a class="headerlink" href="#beanmachine.ppl.compiler.single_assignment.SingleAssignment.fresh_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="beanmachine.ppl.compiler.single_assignment.SingleAssignment.single_assignment">
<code class="descname">single_assignment</code><span class="sig-paren">(</span><em>node: _ast.AST</em><span class="sig-paren">)</span> &#x2192; _ast.AST<a class="headerlink" href="#beanmachine.ppl.compiler.single_assignment.SingleAssignment.single_assignment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="beanmachine.ppl.compiler.single_assignment.single_assignment">
<code class="descclassname">beanmachine.ppl.compiler.single_assignment.</code><code class="descname">single_assignment</code><span class="sig-paren">(</span><em>node: _ast.AST</em><span class="sig-paren">)</span> &#x2192; _ast.AST<a class="headerlink" href="#beanmachine.ppl.compiler.single_assignment.single_assignment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="beanmachine-ppl-compiler-typer-base-module">
<h2>beanmachine.ppl.compiler.typer_base module<a class="headerlink" href="#beanmachine-ppl-compiler-typer-base-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-beanmachine.ppl.compiler">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-beanmachine.ppl.compiler" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="beanmachine.ppl.html" class="btn btn-neutral float-left" title="beanmachine.ppl" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="beanmachine.ppl.diagnostics.html" class="btn btn-neutral float-right" title="diagnostics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Facebook.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>