"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9814],{3905:function(e,r,n){n.r(r),n.d(r,{MDXContext:function(){return s},MDXProvider:function(){return f},mdx:function(){return g},useMDXComponents:function(){return p},withMDXComponents:function(){return m}});var t=n(67294);function o(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function a(){return a=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var n=arguments[r];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},a.apply(this,arguments)}function i(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function c(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?i(Object(n),!0).forEach((function(r){o(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function l(e,r){if(null==e)return{};var n,t,o=function(e,r){if(null==e)return{};var n,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)n=a[t],r.indexOf(n)>=0||(o[n]=e[n]);return o}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)n=a[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=t.createContext({}),m=function(e){return function(r){var n=p(r.components);return t.createElement(e,a({},r,{components:n}))}},p=function(e){var r=t.useContext(s),n=r;return e&&(n="function"==typeof e?e(r):c(c({},r),e)),n},f=function(e){var r=p(e.components);return t.createElement(s.Provider,{value:r},e.children)},u={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},d=t.forwardRef((function(e,r){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=p(n),f=o,d=m["".concat(i,".").concat(f)]||m[f]||u[f]||a;return n?t.createElement(d,c(c({ref:r},s),{},{components:n})):t.createElement(d,c({ref:r},s))}));function g(e,r){var n=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var c={};for(var l in r)hasOwnProperty.call(r,l)&&(c[l]=r[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var s=2;s<a;s++)i[s]=n[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},65937:function(e,r,n){n.r(r),n.d(r,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return m},default:function(){return f}});var t=n(87462),o=n(63366),a=(n(67294),n(3905)),i=["components"],c={},l="Programmable Inference",s={unversionedId:"framework_topics/programmable_inference/programmable_inference",id:"framework_topics/programmable_inference/programmable_inference",isDocsHomePage:!1,title:"Programmable Inference",description:"Bean Machine offers three inference techniques which aim to close the performance gap between general-purpose and model-specific handwritten inference:",source:"@site/../docs/framework_topics/programmable_inference/programmable_inference.md",sourceDirName:"framework_topics/programmable_inference",slug:"/framework_topics/programmable_inference/programmable_inference",permalink:"/docs/framework_topics/programmable_inference/programmable_inference",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/../docs/framework_topics/programmable_inference/programmable_inference.md",tags:[],version:"current",frontMatter:{},sidebar:"someSidebar",previous:{title:"Block and Compositional inference",permalink:"/docs/framework_topics/programmable_inference/compositional_inference"},next:{title:"transforms",permalink:"/docs/framework_topics/programmable_inference/transforms"}},m=[],p={toc:m};function f(e){var r=e.components,n=(0,o.Z)(e,i);return(0,a.mdx)("wrapper",(0,t.Z)({},p,n,{components:r,mdxType:"MDXLayout"}),(0,a.mdx)("h1",{id:"programmable-inference"},"Programmable Inference"),(0,a.mdx)("p",null,"Bean Machine offers three inference techniques which aim to close the performance gap between general-purpose and model-specific handwritten inference:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"Compositional inference: allows the use of different proposal algorithms for each random variable."),(0,a.mdx)("li",{parentName:"ul"},"Block inference: allows multiple variables to be grouped together during inference."),(0,a.mdx)("li",{parentName:"ul"},"Custom proposers: allow users to implement a custom proposal algorithm on a per-variable basis.")),(0,a.mdx)("p",null,"These techniques together, which we call ",(0,a.mdx)("em",{parentName:"p"},"programmable inference, "),"give the inference engine sufficient configurability for users to achieve efficient performance without writing a complete model-specific inference algorithm."),(0,a.mdx)("p",null,"All techniques above are made available through Bean Machine's choice of declarative syntax. Declarative syntax makes the statistical models' dependency structure, directed acyclic graph (DAG), explicit. Random variables are specified independently of the order in which they are sampled during inference and the inference engine has direct access to the code block defining each variable, and can execute these blocks in the order required by the inference algorithm. The fundamental algorithm underlying Bean Machine's inference engine is Single Site Metropolis Hastings (SSMH) ","[?]",", where a new value is proposed for a single variable using a proposal algorithm, and an accept/reject decision is made following the Metropolis Hasting rule. SSMH has been extended in Bean Machine with compositional inference, block inference and custom proposers."))}f.isMDXComponent=!0}}]);