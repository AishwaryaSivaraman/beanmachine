"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7383],{3905:function(e,n,r){r.r(n),r.d(n,{MDXContext:function(){return s},MDXProvider:function(){return c},mdx:function(){return h},useMDXComponents:function(){return m},withMDXComponents:function(){return p}});var t=r(67294);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var t in r)Object.prototype.hasOwnProperty.call(r,t)&&(e[t]=r[t])}return e},i.apply(this,arguments)}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function l(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function d(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},i=Object.keys(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=t.createContext({}),p=function(e){return function(n){var r=m(n.components);return t.createElement(e,i({},n,{components:r}))}},m=function(e){var n=t.useContext(s),r=n;return e&&(r="function"==typeof e?e(n):l(l({},n),e)),r},c=function(e){var n=m(e.components);return t.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},f=t.forwardRef((function(e,n){var r=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),p=m(r),c=a,f=p["".concat(o,".").concat(c)]||p[c]||u[c]||i;return r?t.createElement(f,l(l({ref:n},s),{},{components:r})):t.createElement(f,l({ref:n},s))}));function h(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=f;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var s=2;s<i;s++)o[s]=r[s];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}f.displayName="MDXCreateElement"},13982:function(e,n,r){r.r(n),r.d(n,{frontMatter:function(){return l},contentTitle:function(){return d},metadata:function(){return s},toc:function(){return p},default:function(){return c}});var t=r(87462),a=r(63366),i=(r(67294),r(3905)),o=["components"],l={},d=void 0,s={unversionedId:"framework_topics/custom_proposers/variable",id:"framework_topics/custom_proposers/variable",isDocsHomePage:!1,title:"variable",description:"Worlds and Variables",source:"@site/../docs/framework_topics/custom_proposers/variable.md",sourceDirName:"framework_topics/custom_proposers",slug:"/framework_topics/custom_proposers/variable",permalink:"/docs/framework_topics/custom_proposers/variable",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/../docs/framework_topics/custom_proposers/variable.md",tags:[],version:"current",frontMatter:{}},p=[{value:"Worlds and Variables",id:"worlds-and-variables",children:[{value:"RVIdentifier",id:"rvidentifier",children:[],level:4},{value:"Variable",id:"variable",children:[],level:4},{value:"World",id:"world",children:[],level:4}],level:2}],m={toc:p};function c(e){var n=e.components,r=(0,a.Z)(e,o);return(0,i.mdx)("wrapper",(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h2",{id:"worlds-and-variables"},"Worlds and Variables"),(0,i.mdx)("p",null,"A crucial part of Bean Machine inference is its ability track the state of inference using ",(0,i.mdx)("inlineCode",{parentName:"p"},"World"),"s. During inference, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"World")," represents the state of the variables and their dependencies. The ",(0,i.mdx)("inlineCode",{parentName:"p"},"World")," is a graphical data structure where each node in the graph represents a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Variable")," containing information about the variable's value, distribution, probability, etc. The edges between nodes represent the dependencies between variables. Each variable tracks its parent variables as well as its children variables."),(0,i.mdx)("h4",{id:"rvidentifier"},"RVIdentifier"),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"RVIdentifier")," is a dataclass used to identify the random variable and does not contain any of the inference information. It only consists of the variable's ",(0,i.mdx)("inlineCode",{parentName:"p"},"function")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"arguments")," as supplied in the model declaration."),(0,i.mdx)("h4",{id:"variable"},"Variable"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"Variable")," represents the instantiation of each random variable in a model. Each ",(0,i.mdx)("inlineCode",{parentName:"p"},"RVIdentifier")," has a corresponding ",(0,i.mdx)("inlineCode",{parentName:"p"},"Variable"),". It has the following attributes:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"distribution: Distribution")," - the prior distribution denoted in the modeled"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"value: Tensor")," - the value of the Variable at the current state of inference"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"parent: Set[Optional[RVIdentifier]]")," - the set of random variables called within the function declaration of the random variable"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"children: Set[Optional[RVIdentifier]]")," - the set of random variables which call this variable in their function declaration"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"log_prob: Tensor")," - the log probability of the value with the prior distribution"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"proposal_distribution: ProposalDistribution")," - the proposal distribution used during inference"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_discrete: bool")," - an indicator of whether it is a discrete variable as opposed to a continuous variable"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"transform: Transform")," - a Transform to be applied in order to reshape the state space, see Transform documentation"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"transformed_value: Tensor")," - the value of the variable in the transformed space. This value will be the same as ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," when no transforms are specified."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"jacobian: Tensor")," - the log Jacobian determinant of the transforms")),(0,i.mdx)("p",null,"When writing custom proposers, the two most relevant functions within the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Variable")," API are"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-py"},"transform_value(self, value: Tensor) -> Tensor\ninverse_transform_value(self, transformed_value: Tensor) -> Tensor\n")),(0,i.mdx)("p",null,"Because Bean Machine expects the proposal to be a value in its original space, it may be helpful to use the ",(0,i.mdx)("inlineCode",{parentName:"p"},"variable.transformed_value")," throughout inference before converting back to the original space using ",(0,i.mdx)("inlineCode",{parentName:"p"},"inverse_transform_value"),"."),(0,i.mdx)("h4",{id:"world"},"World"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"World")," tracks the variables through the ",(0,i.mdx)("inlineCode",{parentName:"p"},"WorldVars")," class, which associates each ",(0,i.mdx)("inlineCode",{parentName:"p"},"RVIdentifier")," to a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Variable"),". When new values are proposed to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"World")," and the world is updated to reflect these changes, these changes are stored in the world's ",(0,i.mdx)("inlineCode",{parentName:"p"},"DiffStack"),", which is a stack of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Diff"),"s, each tracking Variables with differing values probabilities, parents, children, etc."),(0,i.mdx)("p",null,"When writing custom proposers for random variables, it is often important to access the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Variable")," corresponding to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"RVIdentifier")," to see the current value, sample from the variable's prior distribution, etc. This can be done through the function"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-py"},"get_node_in_world(node: RVIdentifier, to_be_copied = False, to_create_new_diff = False)\n")),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"to_be_copied"),": a flag indicating if the world should copy this variable to the ",(0,i.mdx)("inlineCode",{parentName:"li"},"DiffStack")," and start tracking changes. Within the ",(0,i.mdx)("inlineCode",{parentName:"li"},"proposal")," method of a proposer, this should generally be set to False, as the world will automatically add the proposed value for the Variable to a ",(0,i.mdx)("inlineCode",{parentName:"li"},"Diff")," once the proposal method is completed."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"to_create_new_diff"),": whether an additional diff with these changes should be added to the top of the ",(0,i.mdx)("inlineCode",{parentName:"li"},"DiffStack"),". This should generally be set to False.")))}c.isMDXComponent=!0}}]);