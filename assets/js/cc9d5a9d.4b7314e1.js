"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9814],{3905:function(e,n,r){r.r(n),r.d(n,{MDXContext:function(){return s},MDXProvider:function(){return f},mdx:function(){return h},useMDXComponents:function(){return p},withMDXComponents:function(){return m}});var t=r(67294);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(){return a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var t in r)Object.prototype.hasOwnProperty.call(r,t)&&(e[t]=r[t])}return e},a.apply(this,arguments)}function i(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function c(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=t.createContext({}),m=function(e){return function(n){var r=p(n.components);return t.createElement(e,a({},n,{components:r}))}},p=function(e){var n=t.useContext(s),r=n;return e&&(r="function"==typeof e?e(n):c(c({},n),e)),r},f=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},d=t.forwardRef((function(e,n){var r=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=p(r),f=o,d=m["".concat(i,".").concat(f)]||m[f]||u[f]||a;return r?t.createElement(d,c(c({ref:n},s),{},{components:r})):t.createElement(d,c({ref:n},s))}));function h(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var s=2;s<a;s++)i[s]=r[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,r)}d.displayName="MDXCreateElement"},65937:function(e,n,r){r.r(n),r.d(n,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return m},default:function(){return f}});var t=r(87462),o=r(63366),a=(r(67294),r(3905)),i=["components"],c={id:"programmable_inference",title:"Programmable Inference",sidebar_label:"Programmable Inference",slug:"/programmable_inference"},l=void 0,s={unversionedId:"framework_topics/programmable_inference/programmable_inference",id:"framework_topics/programmable_inference/programmable_inference",isDocsHomePage:!1,title:"Programmable Inference",description:"Programmable inference is a key feature of Bean Machine, and is achieved through three key techniques:",source:"@site/../docs/framework_topics/programmable_inference/programmable_inference.md",sourceDirName:"framework_topics/programmable_inference",slug:"/programmable_inference",permalink:"/docs/programmable_inference",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/../docs/framework_topics/programmable_inference/programmable_inference.md",tags:[],version:"current",frontMatter:{id:"programmable_inference",title:"Programmable Inference",sidebar_label:"Programmable Inference",slug:"/programmable_inference"},sidebar:"someSidebar",previous:{title:"Newtonian Monte Carlo",permalink:"/docs/newtonian_monte_carlo"},next:{title:"Block and Compositional Inference",permalink:"/docs/compositional_inference"}},m=[],p={toc:m};function f(e){var n=e.components,r=(0,o.Z)(e,i);return(0,a.mdx)("wrapper",(0,t.Z)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"Programmable inference is a key feature of Bean Machine, and is achieved through three key techniques:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"Compositional inference allows you to utilize distinct inference methods for different random variables when fitting a model. Bean Machines's single-site paradigm makes composeability possible as it allows you to modularly mix-and-match inference components to get the most out of your model."),(0,a.mdx)("li",{parentName:"ul"},"Block inference allows you to propose updates for several random variables jointly, which can be necessary when dealing with highly-correlated variables."),(0,a.mdx)("li",{parentName:"ul"},"Custom proposers allow you to leverage domain-specific transformations or custom proposers on a per-variable basis, which can be especially powerful to avoid worse edge-case performance when running inference over constrained random variables.")),(0,a.mdx)("p",null,"These techniques together, which we call ",(0,a.mdx)("em",{parentName:"p"},"programmable inference, "),"give the inference engine sufficient configurability for users to achieve efficient performance without writing a complete model-specific inference algorithm, and help close the performance gap between general-purpose and model-specific handwritten inference.  In the rest of this section we expand on each of these concepts."),(0,a.mdx)("p",null,"It is worth noting that supporting these techniques is facilitiated by Bean Machine's choice of declarative syntax, which explicates the statistical models' dependency structure, namely, the directed acyclic graph (DAG). Random variables are specified independently of the order in which they are sampled during inference and the inference engine has direct access to the code block defining each variable, and can execute these blocks in the order required by the inference algorithm. The fundamental algorithm underlying Bean Machine's inference engine is Single Site Metropolis Hastings (SSMH) ","[?]",", where a new value is proposed for a single variable using a proposal algorithm, and an accept/reject decision is made following the Metropolis Hasting rule. SSMH has been extended in Bean Machine with compositional inference, block inference and custom proposers."))}f.isMDXComponent=!0}}]);